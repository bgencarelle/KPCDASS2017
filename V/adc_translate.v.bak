
module adc_translate(

output wire signed [11:0] out_adc_8,
output wire signed [11:0] out_adc_7,
output wire signed [11:0] out_adc_6,
output wire signed [11:0] out_adc_5,
output wire signed [11:0] out_adc_4,
output wire signed [11:0] out_adc_3,
output wire signed [11:0] out_adc_2,
output wire signed [11:0] out_adc_1,
output wire signed [11:0] out_adc_0,

input wire pll1_locked, 
input wire clk, 
input wire pll1_c0,
input wire reset
);

	wire 		[4:0]rspn_ch;
	reg  		cmd_valid;
	wire 		[4:0]cmd_channel;
	reg		cmd_sop;
	wire		cmd_eop;
	wire		cmd_rdy;


ADC_Converter u0(

	.clock_clk(clk),
	.reset_sink_reset_n(reset),
	.adc_pll_clock_clk(pll1_c0),
	.adc_pll_locked_export(pll1_locked),

	.command_valid(cmd_valid),
	.command_channel(cmd_channel),
	.command_startofpacket(cmd_sop),
	.command_endofpacket(cmd_eop),
	.command_ready(cmd_rdy),
	.response_valid(rspn_valid),
	.response_channel(rspn_ch),
	.response_data(rspn_data)
	
	);	



	reg [15:0]lock_dly_cnt;
	always@(posedge clk;)	
		if ( pll1_locked && lock_dly_cnt != 10d'1000 )
			lock_dly_cnt <= lock_dly_cnt + 1;
	
	wire lock_rdy = (lock_dly_cnt == 1000)? 1 : 0;	
	
	
	assign cmd_channel = SW[3:0];
	
	always@(posedge clk)
	 begin
		cmd_valid <= lock_rdy;
		if (cmd_rdy && cmd_valid)
			cmd_sop <= 0;
		else if (lock_rdy)
			cmd_sop <= 1;
	 end
	
	reg [11:0]adc_data;
	wire rspn_valid;
	wire [11:0]rspn_data;
	always@(posedge clk)
		if (rspn_valid && rspn_ch == cmd_channel)
			adc_data <= rspn_data;


	
			
endmodule
