
//================================================//  This code is generated by Terasic System Builder
//================================================
module adc_mic_lcd #(parameter BIT_WIDTH = 24, parameter RANGE = BIT_WIDTH-1,
							parameter TRUNC_RANGE = 15, parameter TRUNC = RANGE-TRUNC_RANGE)
							//TRUNC instead of 0 makes scaling easier
							(

	//////////// CLOCK //////////
	input 		          		ADC_CLK_10,
	input 		          		MAX10_CLK1_50,
	input 		          		MAX10_CLK2_50,
	input 		          		MAX10_CLK3_50,

	//////////// KEY //////////
	input 		          		FPGA_RESET_n,
	input 		     [4:0]		KEY,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// LEDR //////////
	output		     [9:0]		LEDR,

	//////////// HEX //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,

	//////////// Audio //////////
	inout 		          		AUDIO_BCLK,
	output		          		AUDIO_DIN_MFP1,
	input 		          		AUDIO_DOUT_MFP2,
	inout 		          		AUDIO_GPIO_MFP5,
	output		          		AUDIO_MCLK,
	input 		          		AUDIO_MISO_MFP4,
	inout 		          		AUDIO_RESET_n,
	output		          		AUDIO_SCL_SS_n,
	output		          		AUDIO_SCLK_MFP3,
	inout 		          		AUDIO_SDA_MOSI,
	output		          		AUDIO_SPI_SELECT,
	inout 		          		AUDIO_WCLK,//48khz

	//////////// DAC //////////
	inout 		          		DAC_DATA,
	output		          		DAC_SCLK,
	output		          		DAC_SYNC_n,

//	//////////// MTL2 //////////
//	output		     [7:0]		MTL2_B,
//	output		          		MTL2_BL_ON_n,
//	output		          		MTL2_DCLK,
//	output		     [7:0]		MTL2_G,
//	output		          		MTL2_HSD,
//	output		          		MTL2_I2C_SCL,
//	inout 		          		MTL2_I2C_SDA,
//	input 		          		MTL2_INT,
//	output		     [7:0]		MTL2_R,
//	output		          		MTL2_VSD,
//
//	//////////// PS2 //////////
//	inout 		          		PS2_CLK,
//	inout 		          		PS2_CLK2,
//	inout 		          		PS2_DAT,
//	inout 		          		PS2_DAT2,

	//////////// TMD 2x6 GPIO Header, TMD connect to TMD Default //////////
	output 		     [7:0]		GPIO

);



//----ON-BOARD-MIC TO DAC&LINE out-----

//================================================//  REG/WIRE declarations
//================================================// ### USER DEFINED
wire signed [15:0]		PWM_OUT;
wire signed [RANGE:0]		MEMC;
wire signed [RANGE:0]		MEMD;
wire signed [RANGE:0]		MEMDb;
wire signed [RANGE:0]		MEME;
wire signed [RANGE:0]		MEMEb;
wire signed [RANGE:0]		MEMF;
wire signed [RANGE:0]		MEMG;
wire signed [RANGE:0]		MEMGb;
wire signed [RANGE:0]		MEMA;
wire signed [RANGE:0]		MEMAb;
wire signed [RANGE:0]		MEMB;
wire signed [RANGE:0]		MEMBb;

wire signed [RANGE+4:0]		VERB0;

wire signed [15:0]		NOISE7;
wire signed [15:0]		NOISE6;
wire signed [15:0]		NOISE5;
wire signed [15:0]		NOISE4;
wire signed [15:0]		NOISE3;
wire signed [15:0]		NOISE2;
wire signed [15:0]		NOISE1;
wire signed [15:0]		NOISE0;

reg signed [RANGE+1:0]		MIX_01;
reg signed [RANGE+1:0]		MIX_23;

wire signed [RANGE:0]		SEED_OUT;
wire signed [RANGE:0] 		FILTER_OUT;
wire signed [RANGE:0]		MUX0_OUT;
wire signed [RANGE:0]		MUX1_OUT;
wire signed [RANGE:0] 	MASTER_OUT;
wire 			  			key_0;
reg 			  			GPIOCLK;
wire 	[6:0]	  			HEXR;
wire 	[6:0]	  			HEXL;
//wire [RANGE:0]		SAW_OUT
//wire

//  ### PREDEFINED
wire 	[11:0]			ADC_RD ;
wire    					SAMPLE_TR ;
wire          			ADC_RESPONSE ;
wire  [RANGE:0]  TODAC ;
wire          			ROM_CK ;
wire          			MCLK_48M ; // 48MHZ
wire  [RANGE:TRUNC]   	SUM_AUDIO ;
wire	[9:0]   			LED ; //mistake in standard implementation
wire          			MTL_CLK ;  // 33MHZ
reg           			RESET_DELAY_n ;
reg   [31:0]  			DELAY_CNT;


//================================================//  Structural coding


//================================================// ### KARPLUS AND AUDIO STUFF GOES HERE!!


wire signed [RANGE:0] MIXMASTER;

assign MIXMASTER = $signed(sum0);

wire seven0068khz_clk;
wire clkbuff;
	
	clock_buff buff (
		.inclk  (clkbuff),  //  altclkctrl_input.inclk
		.outclk (seven0068khz_clk)  // altclkctrl_output.outclk
	);	
	altclk clockyclock(//added clock, infinitely better sound.
	.inclk0 (MAX10_CLK1_50),
	.c0 (clkbuff)
	);

	


ADC_SEG_LED segR(//this will be modified to display Note name and number
			.reset_n(RESET_DELAY_n),
			.clk (MAX10_CLK1_50),
			.adc_rd (MIXMASTER [23:20]),
			.LED(LED),
			.HEXR(HEXL)
			);
ADC_SEG_LED segL(
			.reset_n(RESET_DELAY_n),
			.clk (MAX10_CLK1_50),
			.adc_rd (MIXMASTER [19:16]),
			.HEXR(HEXR)
			);

//--METER TO LED --
assign LEDR =  ({7'd0,SW[9],SW[8]});
assign HEX0 = HEXL;
assign HEX1 = HEXR;
//--RESET DELAY ---

//// END USER DEFINED



always @(negedge FPGA_RESET_n or posedge MAX10_CLK2_50 )
begin

if (!FPGA_RESET_n )
	begin
     RESET_DELAY_n <=0;
     DELAY_CNT   <=0;
	end

	else  if ( DELAY_CNT < 32'h00fff  )
  begin
  DELAY_CNT<=DELAY_CNT+1'b1;
  end
 else
	begin
		RESET_DELAY_n <=1;
	end


end
//
////--- MIC  TO  MAX10-ADC  ----
//
//MAX10_ADC   madc(
//	.SYS_CLK ( MAX10_CLK1_50   ),
//	.SYNC_TR ( SAMPLE_TR    ),
//	.RESET_n ( RESET_DELAY_n),
//	.ADC_CH  ( 8),
//	.DATA    (ADC_RD ) ,
//	.DATA_VALID(ADC_RESPONSE),
//	.FITER_EN (1)
// );

//--------------DAC out --------------------
assign      TODAC = $signed({~MIXMASTER[RANGE] ,  MIXMASTER[RANGE-1:0] })  ;
//
DAC16 dac1 (
	.LOAD    ( seven0068khz_clk   ) ,
	.RESET_N ( RESET_DELAY_n) ,
	.CLK_50  ( MAX10_CLK1_50 ) ,
	.DATA24  ( TODAC  )  ,
	.DIN     ( DAC_DATA ),
	.SCLK    ( DAC_SCLK ),
	.SYNC    ( DAC_SYNC_n )

	);
reg signed [23:0] weighted_noise_C;
reg signed [23:0] weighted_noise_Db;
reg signed [23:0] weighted_noise_D;
reg signed [23:0] weighted_noise_Eb;
reg signed [23:0] weighted_noise_E;
reg signed [23:0] weighted_noise_F;
reg signed [23:0] weighted_noise_Gb;
reg signed [23:0] weighted_noise_G;
reg signed [23:0] weighted_noise_Ab;
reg signed [23:0] weighted_noise_A;
reg signed [23:0] weighted_noise_Bb;
reg signed [23:0] weighted_noise_B;

KP_main stringC(  /// HIGH STRING
		  .audio_clk(a_clk),
			.a_clk_wire(clock_C),
		  .dnoise(weighted_noise_C),
		  .decay({SW[9:4],6'b111111}),
		  .filtsw(3'b000),//each filter can be tuned to the specific string
		  .trig(KEYMIX0),
		  .delay_length(11'd1959),
		  .reset_n(RESET_DELAY_n),
        .qout(MEMC)
        );

KP_main stringDb(
		  .audio_clk(a_clk),
			.a_clk_wire(clock_Db),
		  .dnoise(weighted_noise_Db),
		  .decay({SW[9:4],6'b111111}),
		  .loops(3'b110),
		  .filtsw(3'b001),
		  .trig(KEYMIX1),
		  .delay_length(11'd1959),
		  .reset_n(RESET_DELAY_n),
        .qout(MEMDb)
        );

KP_main stringD(
		  .audio_clk(a_clk),
			.a_clk_wire(clock_D),
		   .dnoise(weighted_noise_D),
		  .decay({SW[9:4],6'b111111}),
		  .loops(3'b101),
		  .filtsw(3'b010),
		  .trig(KEYMIX2),
		  .delay_length(11'd1959),
		  .reset_n(RESET_DELAY_n),
        .qout(MEMD)
        );
KP_main stringEb (
		  .audio_clk(a_clk),
			.a_clk_wire(clock_Eb),
		  .dnoise(weighted_noise_Eb),
		  .decay({SW[9:4],6'b111111}),
		  .loops(3'b001),
		  .filtsw(3'b001),
		  .trig(KEY[4]),
		  .delay_length(10'd960),
		  .reset_n(RESET_DELAY_n),
        .qout(MEMEb)
        );

KP_main stringE(
		  .audio_clk(a_clk),
			.a_clk_wire(clock_E),
		   .dnoise(weighted_noise_E),
		  .decay({SW[9:4],6'b111111}),
		  .loops(3'b010),
		  .filtsw(3'b001),
		  .trig(KEY[3]),
		  .delay_length(10'd480),
		  .reset_n(RESET_DELAY_n),
        .qout(MEME)
        );

KP_main stringF(  //low string
		  .audio_clk(a_clk),
			.a_clk_wire(clock_F),
		   .dnoise(weighted_noise_F),
		  .decay({SW[9:4],6'b111111}),
		  .loops(3'b001),
		  .filtsw(3'b001),
		  .trig(KEY[2]),
		  .delay_length(10'd480),
		  .reset_n(RESET_DELAY_n),
        .qout(MEMF)
        );

KP_main stringGb(  
		  .audio_clk(a_clk),
			.a_clk_wire(clock_Gb),
		   .dnoise(weighted_noise_Gb),
		  .decay({SW[9:4],6'b111111}),
		  .filtsw(3'b001),
		  .trig(KEY[1]),
		  .delay_length(10'd0959),
		  .reset_n(RESET_DELAY_n),
        .qout(MEMGb)
        );

KP_main stringG(  
		  .audio_clk(a_clk),
			.a_clk_wire(clock_G),
		   .dnoise(weighted_noise_G),
		  .decay({SW[9:4],6'b111111}),
		  .filtsw(3'b001),
		  .trig(KEY[1]),
		  .delay_length(10'd0959),
		  .reset_n(RESET_DELAY_n),
        .qout(MEMG)
        );

KP_main stringAb(  
		  .audio_clk(a_clk),
			.a_clk_wire(clock_Ab),
		   .dnoise(weighted_noise_Ab),
		  .decay({SW[9:4],6'b111111}),
		  .filtsw(3'b001),
		  .trig(KEY[1]),
		  .delay_length(10'd0959),
		  .reset_n(RESET_DELAY_n),
        .qout(MEMAb)
        );


KP_main stringA(  
		  .audio_clk(a_clk),
			.a_clk_wire(clock_A),
		   .dnoise(weighted_noise_A),
		  .decay({SW[9:4],6'b111111}),
		  .filtsw(3'b001),
		  .trig(KEY[1]),
		  .delay_length(10'd0959),
		  .reset_n(RESET_DELAY_n),
        .qout(MEMA)
        );
		  
KP_main stringBb(  
		  .audio_clk(a_clk),
			.a_clk_wire(clock_Bb),
		   .dnoise(weighted_noise_Bb),
		  .decay({SW[9:4],6'b111111}),
		  .filtsw(3'b001),
		  .trig(KEY[1]),
		  .delay_length(10'd0959),
		  .reset_n(RESET_DELAY_n),
        .qout(MEMBb)
        );
		  
KP_main stringB(  
		  .audio_clk(a_clk),
			.a_clk_wire(clock_B),
		   .dnoise(weighted_noise_B),
		  .decay({SW[9:4],6'b111111}),
		  .filtsw(3'b001),
		  .trig(KEY[1]),
		  .delay_length(10'd0959),
		  .reset_n(RESET_DELAY_n),
        .qout(MEMB)
        );		  
		  

reg signed [25:0]presum;
reg signed [23:0]sum0;
reg signed [23:0]sum1;

	always @(posedge a_clk) //will move mixer to another .V file at some point
	begin
 //	//a bit of borrowed code
    presum <=  $signed(MEMC>>>2) + $signed(MEMDb>>>2) + $signed(MEMD>>>2)+ $signed(MEMEb>>>2) + 
					+$signed(MEME>>>2) + $signed(MEMF>>>2)+ $signed(MEMG>>>2) 
					+$signed(MEMGb>>>2) + $signed(MEMAb>>>2)+ $signed(MEMA>>>2)+ $signed(MEMBb>>>2)+ $signed(MEMB>>>2);
    sum1 <= sum0;
	 if (presum[25] == presum[23])
		begin
      // Top two bits equal: no signed overflow.
      sum0 <= $signed(presum[23:0]);  // truncate sum back to 8 bits.
		end
    else
      if (presum[25] == 1'b0)
        begin
        sum0 <= 24'd8388607;   // maximum positive value representable by 24 bits.
		  end
      else
			begin
        sum0 <= 24'd8388608;   
			end
		
  end
  


endmodule
