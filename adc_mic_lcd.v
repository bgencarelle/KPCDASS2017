
//================================================//  This code is generated by Terasic System Builder
//================================================
module adc_mic_lcd #(parameter BIT_WIDTH = 24, parameter RANGE = BIT_WIDTH-1,
							parameter TRUNC_RANGE = 15, parameter TRUNC = RANGE-TRUNC_RANGE)
							//TRUNC instead of 0 makes scaling easier
							(

	//////////// CLOCK //////////
	input 		          		ADC_CLK_10,
	input 		          		MAX10_CLK1_50,
	input 		          		MAX10_CLK2_50,
//	input 		          		MAX10_CLK3_50,

	//////////// KEY //////////
	input 		          		FPGA_RESET_n,
	input 		     [4:0]		KEY,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// LEDR //////////
	output		     [9:0]		LEDR,

	//////////// HEX //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,

	//////////// Audio //////////
	inout 		          		AUDIO_BCLK,
//	output		          		AUDIO_DIN_MFP1,
//	input 		          		AUDIO_DOUT_MFP2,
	inout 		          		AUDIO_GPIO_MFP5,
//	output		          		AUDIO_MCLK,
//	input 		          		AUDIO_MISO_MFP4,
	inout 		          		AUDIO_RESET_n,
//	output		          		AUDIO_SCL_SS_n,
//	output		          		AUDIO_SCLK_MFP3,
	inout 		          		AUDIO_SDA_MOSI,
//	output		          		AUDIO_SPI_SELECT,
	inout 		          		AUDIO_WCLK,//48khz

	//////////// DAC //////////
	inout 		          		DAC_DATA,
	output		          		DAC_SCLK,
	output		          		DAC_SYNC_n,

//	//////////// MTL2 //////////
//	output		     [7:0]		MTL2_B,
//	output		          		MTL2_BL_ON_n,
//	output		          		MTL2_DCLK,
//	output		     [7:0]		MTL2_G,
//	output		          		MTL2_HSD,
//	output		          		MTL2_I2C_SCL,
//	inout 		          		MTL2_I2C_SDA,
//	input 		          		MTL2_INT,
//	output		     [7:0]		MTL2_R,
//	output		          		MTL2_VSD,
//
//	//////////// PS2 //////////
//	inout 		          		PS2_CLK,
//	inout 		          		PS2_CLK2,
//	inout 		          		PS2_DAT,
//	inout 		          		PS2_DAT2,

	//////////// TMD 2x6 GPIO Header, TMD connect to TMD Default //////////
	output 		     [7:0]		GPIO

);



//----ON-BOARD-MIC TO DAC&LINE out-----

//================================================//  REG/WIRE declarations
//================================================// ### USER DEFINED
wire signed [15:0]		PWM_OUT;
wire signed [RANGE:0]		MEM_0;
wire signed [RANGE:0]		MEM_1;
wire signed [RANGE:0]		MEM_2;
wire signed [RANGE:0]		MEM_3;
wire signed [RANGE:0]		MEM_4;
wire signed [RANGE:0]		MEM_5;
wire signed [RANGE:0]		MEM_6;
wire signed [RANGE:0]		MEM_7;
wire signed [RANGE:0]		MEM_8;
wire signed [RANGE:0]		MEM_DELAY;
wire signed [RANGE:0]		MEM_PHASE;


wire signed [15:0]		NOISE_8;
wire signed [15:0]		NOISE_7;
wire signed [15:0]		NOISE_6;
wire signed [15:0]		NOISE_5;
wire signed [15:0]		NOISE_4;
wire signed [15:0]		NOISE_3;
wire signed [15:0]		NOISE_2;
wire signed [15:0]		NOISE_1;
wire signed [15:0]		NOISE_0;

reg signed [RANGE+1:0]		MIX_01;
reg signed [RANGE+1:0]		MIX_23;

wire signed [RANGE:0]		SEED_OUT;
wire signed [RANGE:0] 		FILTER_OUT;
wire signed [RANGE:0]		MUX0_OUT;
wire signed [RANGE:0]		MUX1_OUT;
wire signed [RANGE:0] 	MASTER_OUT;
wire 			  			key_0;
reg 			  			GPIOCLK;
wire 	[6:0]	  			HEXR;
wire 	[6:0]	  			HEXL;
//wire [RANGE:0]		SAW_OUT
//wire

//  ### PREDEFINED
wire 	[11:0]			ADC_RD ;
wire    					SAMPLE_TR ;
wire          			ADC_RESPONSE ;
wire  [RANGE:0]  TODAC ;
wire          			ROM_CK ;
wire          			MCLK_48M ; // 48MHZ
wire  [RANGE:TRUNC]   	SUM_AUDIO ;
wire	[9:0]   			LED ; //mistake in standard implementation
wire          			MTL_CLK ;  // 33MHZ
reg           			RESET_DELAY_n ;
reg   [31:0]  			DELAY_CNT;


//================================================//  Structural coding


//================================================// ### KARPLUS AND AUDIO STUFF GOES HERE!!



//	wire KEYMIX;
//	assign KEYMIX0 = (~SW[0] & KEY[0]) ? 1'b1 : 1'b0;
//	assign KEYMIX1 = (~SW[1] & KEY[1]) ? 1'b1 : 1'b0;
//	assign KEYMIX2 = (~SW[2] & KEY[2]) ? 1'b1 : 1'b0;
//	assign KEYMIX3 = (~SW[3] & KEY[3]) ? 1'b1 : 1'b0;

	wire seven0068khz_clk;
	wire clkbuff;
	
	clock_buff buff (
		.inclk  (clkbuff),  //  altclkctrl_input.inclk
		.outclk (seven0068khz_clk)  // altclkctrl_output.outclk
	);	
	
	altclk clockyclock(//added clock, infinitely better sound.
	.inclk0 (MAX10_CLK1_50),
	.c0 (clkbuff)
	);




wire a_clk_2;
wire a_clk_4;
wire a_clk_8;
wire a_clk_16;
wire a_clk_32;
wire a_clk_64;
wire a_clk_128;
wire a_clk_256;
wire a_clk_div;

multi_clk_div div(
		.div_clock(12'd32),
		.reset(RESET_DELAY_n),
		.clk(seven0068khz_clk),
		.div_var(a_clk_div),
		.div2(a_clk_2),
		.div4(a_clk_4),
		.div8(a_clk_8),
		.div16(a_clk_16),
 		.div32(a_clk_32),
		.div64(a_clk_64),
		.div128(a_clk_128),
		.div256(a_clk_256)
		);
wire [2:0] sw_filt;
wire [11:0] sw_decay;

assign sw_filt = {1'b0,SW[1:0]};
assign sw_decay = out_adc_0 ;

KP_main string0(  /// HIGH STRING
			.m_clk(MAX10_CLK1_50),
		  .audio_clk(a_clk_16),
		  .dnoise(NOISE_0),
		  .velocity(7'd127),
		  .decay(sw_decay),
		  .filtsw(sw_filt ),//each filter can be tuned to the specific string
		  .trig(KEY[4]),
		  .delay_length(11'd950),
		  .reset_n(RESET_DELAY_n),
        .qout(MEM_0)
        );

KP_main string1(
			.m_clk(MAX10_CLK1_50),
		  .audio_clk(a_clk_4),
		  .dnoise(NOISE_1),
		  .velocity(7'd127),
		  .decay(sw_decay),
		  .filtsw(sw_filt ),
		  .trig(KEY[4]),
		  .delay_length(11'd959),
		  .reset_n(RESET_DELAY_n),
        .qout(MEM_1)
        );

KP_main string2(
			.m_clk(MAX10_CLK1_50),
		  .audio_clk(a_clk_4),
		   .dnoise(NOISE_2),
		  .velocity(7'd127),
		  .decay(sw_decay),
		  .filtsw(sw_filt),
		  .trig(KEY[4]),
		  .delay_length(11'd959),
		  .reset_n(RESET_DELAY_n),
        .qout(MEM_2)
        );
		  
KP_main string3 (
			.m_clk(seven0068khz_clk),
		  .audio_clk(a_clk_4),
		  .dnoise(NOISE_3),
		  .velocity(7'd127),
		  .decay(sw_decay),
		  .filtsw(sw_filt),
		  .trig(KEY[4]),
		  .delay_length(10'd575),
		  .reset_n(RESET_DELAY_n),
        .qout(MEM_3)
        );

KP_main string4(
			.m_clk(seven0068khz_clk),
		  .audio_clk(a_clk_4),
		   .dnoise(NOISE_4),
		  .velocity(7'd127),
		  .decay(sw_decay),
		  .filtsw(sw_filt),
		  .trig(KEY[3]),
		  .delay_length(10'd773),
		  .reset_n(RESET_DELAY_n),
        .qout(MEM_4)
        );

KP_main string5(
			.m_clk(seven0068khz_clk),
		  .audio_clk(a_clk_4),
		   .dnoise(NOISE_5),
		  .velocity(7'd127),
		  .decay(sw_decay),
		  .filtsw(sw_filt),
		  .trig(KEY[2]),
		  .delay_length(10'd974),
		  .reset_n(RESET_DELAY_n),
        .qout(MEM_5)
        );

KP_main string6(  
			.m_clk(seven0068khz_clk),
		  .audio_clk(a_clk_8),
		   .dnoise(NOISE_6),
		  .velocity(7'd127),
		  .decay(sw_decay),
		  .filtsw(sw_filt),
		  .trig(KEY[1]),
		  .delay_length(10'd650),
		  .reset_n(RESET_DELAY_n),
        .qout(MEM_6)
        );

KP_main string7(  
			.m_clk(seven0068khz_clk),
		  .audio_clk(a_clk_8),
		   .dnoise(NOISE_7),
		  .velocity(7'd127),
		  .decay(sw_decay),
		  .filtsw(sw_filt),
		  .trig(KEY[1]),
		  .delay_length(10'd865),
		  .reset_n(RESET_DELAY_n),
        .qout(MEM_7)
        );

KP_main string8(  
			.m_clk(seven0068khz_clk),
		  .audio_clk(a_clk_16),
		   .dnoise(NOISE_8),
		  .velocity(7'd127),
		  .decay(sw_decay),
		  .filtsw(sw_filt),
		  .trig(KEY[0]),
		  .delay_length(10'd862),
		  .reset_n(RESET_DELAY_n),
        .qout(MEM_8)
        );

					
wire signed [24:0]presub;
reg signed [23:0]sub0;
 assign   presub = $signed(MEM_DELAY)+ $signed(MEM_8)+ $signed(MEM_6)+ $signed(MEM_5) 
					+$signed(MEM_4) + $signed(MEM_3)+ $signed(MEM_2)+ $signed(MEM_1) + $signed(MEM_0);
					
	always @(posedge seven0068khz_clk) //will move mixer to another .V file at some point
	begin
 //	//a bit of borrowed code

	 if (presub[24] == presub[23])
		begin
      // Top two bits equal: no signed overflow.
      sub0 <= $signed(presub[23:0]);  // truncate sum back to 8 bits.
		end
    else
      if (presub[24] == 1'b0)
        begin
        sub0 <= 2**23;   // maximum positive value representable by 24 bits.
		  end
      else
			begin
        sub0 <= (2**23)-1;   
			end
		
  end


wire signed [24:0]presum;
wire signed [23:0]sum0;

assign presum = $signed(MEM_DELAY)+$signed(MEM_8) +$signed(MEM_7) + $signed(MEM_6)+ $signed(MEM_5) 
					+$signed(MEM_4) + $signed(MEM_3)+ $signed(MEM_2)+ $signed(MEM_1)+ $signed(MEM_0);
					
assign sum0 = (presum[24] == presum[23])?$signed(presum[23:0]):(presum[24] == 1'b0)?24'd8388607:24'd8388608;
wire signed [23:0] submix;

mainfilter lpf_mix0(//FILTER, depth of filter controlled by input to filt_sel
			.filt_sel({3'b100}),
			.clk(seven0068khz_clk),
			.d(sum0),
			.reset_n(RESET_DELAY_n),
			.q(submix) // output to DAC
			);
			
 wire signed [23:0] sub1;					

mainfilter lpf_mix1(//FILTER, depth of filter controlled by input to filt_sel
			.filt_sel(3'b011),
			.clk(a_clk_4),
			.d(submix),
			.reset_n(RESET_DELAY_n),
			.q(sub1) // output to DAC
			);

wire signed [RANGE:0] MIXMASTER;

assign MIXMASTER = sub1;

KP_delay effect(  //low string
			.m_clk(MAX10_CLK1_50),
		  .audio_clk(a_clk_8),
	//	  .reverse(a_clk256),
		   .dnoise(sub1),
		  .velocity(7'd127),
		  .decay(12'b111111111111),

		  .filtsw(sw_filt[0]),
		  .trig(KEY[0]),
		  .delay_length(15'd1063),//gates of hell
		  .reset_n(RESET_DELAY_n),
        .qout(MEM_DELAY)
        );


	
lfsr noise_gen(//easier to add more voices, shown to be marginally cheaper
			.out24_8(NOISE_8),
			.out24_7(NOISE_7),
			.out24_6(NOISE_6),
			.out24_5(NOISE_5),
			.out24_4(NOISE_4),
			.out24_3(NOISE_3),
			.out24_2(NOISE_2),
			.out24_1(NOISE_1),
			.out24_0(NOISE_0),
			.clk(MAX10_CLK1_50),
			.a_clk(seven0068khz_clk),
			.reset(RESET_DELAY_n)
					);

ADC_SEG_LED segR(//this will be modified to display Note name and number
			.reset_n(RESET_DELAY_n),
			.clk (MAX10_CLK1_50),
			.adc_rd (out_adc_0[11:8]),
			.LED(LED),
			.HEXR(HEXL)
			);
ADC_SEG_LED segL(
			.reset_n(RESET_DELAY_n),
			.clk (MAX10_CLK1_50),
			.adc_rd (out_adc_0[7:4]),
			.HEXR(HEXR)
			);

//--METER TO LED --
assign LEDR =  (HEXL);
assign HEX0 = HEXL;
assign HEX1 = HEXR;



wire [11:0] out_adc_0;

 adc_translate(

     .out_adc_8(),
     .out_adc_7(),
     .out_adc_6(),
     .out_adc_5(),
     .out_adc_4(),
     .out_adc_3(),
     .out_adc_2(),
     .out_adc_1(),
     .out_adc_0(out_adc_0),
		.key(KEY[0]), 
     .clk(MAX10_CLK2_50), 
     .reset(RESET_DELAY_n)
);
//// END USER DEFINED
assign GPIO[0] = seven0068khz_clk;



//--I2S PROCESSS  CODEC LINE OUT --
//
//I2S_ASSESS  i2s(
//	.SAMPLE_TR ( SAMPLE_TR),
//	.AUDIO_MCLK( MAX10_CLK1_50) ,
//	.AUDIO_BCLK( AUDIO_BCLK),
//	.AUDIO_WCLK( AUDIO_WCLK),
//
//	.SDATA_OUT ( AUDIO_DIN_MFP1),
//	.SDATA_IN  ( AUDIO_DOUT_MFP2),
//	.RESET_n   ( RESET_DELAY_n),
//	.ADC_MIC      ( MASTER_OUT),
//	.SW_BYPASS    ( 0),          // 0:on-board mic  , 1 :line-in
//	.SW_OBMIC_SIN ( 0),          // 1:sin  , 0 : mic
////	.ROM_ADDR     ( ROM_ADDR),
//	.ROM_CK       ( ROM_CK ),
//	.SUM_AUDIO    ( SUM_AUDIO )
//
//	) ;


always @(negedge FPGA_RESET_n or posedge MAX10_CLK2_50 )
begin

if (!FPGA_RESET_n )
	begin
     RESET_DELAY_n <=0;
     DELAY_CNT   <=0;
	end

	else  if ( DELAY_CNT < 32'h00fff  )
  begin
  DELAY_CNT<=DELAY_CNT+1'b1;
  end
 else
	begin
		RESET_DELAY_n <=1;
	end


end
//
////--- MIC  TO  MAX10-ADC  ----
//
//MAX10_ADC   madc(
//	.SYS_CLK ( MAX10_CLK1_50   ),
//	.SYNC_TR ( SAMPLE_TR    ),
//	.RESET_n ( RESET_DELAY_n),
//	.ADC_CH  ( 8),
//	.DATA    (ADC_RD ) ,
//	.DATA_VALID(ADC_RESPONSE),
//	.FITER_EN (1)
// );

//--------------DAC out --------------------
assign      TODAC = $signed({~MIXMASTER[RANGE] ,  MIXMASTER[RANGE-1:0] })  ;
//
DAC16 dac1 (

	.RESET_N ( RESET_DELAY_n) ,
	.CLK_50  ( MAX10_CLK1_50 ) ,
	.DATA24  ( TODAC  )  ,
	.DIN     ( DAC_DATA ),
	.SCLK    ( DAC_SCLK ),
	.SYNC    ( DAC_SYNC_n )

	);



//---AUDIO CODEC SPI CONFIG ------------------------------------
//--I2S mode ,  48ksample rate  ,MCLK = 24.567MhZ x 2
//assign AUDIO_GPIO_MFP5  =  1;   //GPIO
//assign AUDIO_SPI_SELECT =  1;   //SPI mode
//assign AUDIO_RESET_n    =  RESET_DELAY_n ;
//
//AUDIO_SPI_CTL_RD	u1(
//	.iRESET_n ( RESET_DELAY_n) ,
//	.iCLK_50( MAX10_CLK1_50),   //50Mhz clock
//	.oCS_n ( AUDIO_SCL_SS_n ),   //SPI interface mode chip-select signal
//	.oSCLK ( AUDIO_SCLK_MFP3),  //SPI serial clock
//	.oDIN  ( AUDIO_SDA_MOSI ),   //SPI Serial data output
//	.iDOUT ( AUDIO_MISO_MFP4)   //SPI serial data input
//
//	);



//---MTL2 ---
//PLL_VGA PP(
//	.areset ( 0),
//	.inclk0 ( MAX10_CLK3_50) ,
//	.c0     ( MTL_CLK),
//	.locked ()
//);

//--SOUND-WAVE display to MTL2 ----
//assign  MTL2_BL_ON_n = ~RESET_DELAY_n  ;
//
//SOUND_TO_MTL2  sm(
//	.WAVE      ( SUM_AUDIO),
//	.AUDIO_MCLK( AUDIO_MCLK),
//	.SAMPLE_TR ( SAMPLE_TR),
//	.RESET_n   ( RESET_DELAY_n),
//
//	.MTL_CLK  ( MTL_CLK  ),
//	.MTL2_R   ( MTL2_R   ),
//	.MTL2_G   ( MTL2_G   ),
//	.MTL2_B   ( MTL2_B   ),
//   .MTL2_HSD ( MTL2_HSD ),
//   .MTL2_VSD ( MTL2_VSD ),
//   .MTL2_DCLK( MTL2_DCLK) ,
//   .SCAL      ( 7), //0:NONE SCA  1: SCALE+1  ...
//	.DRAW_DOT  ( 0),
//	.START_STOP( 1)
//);

 

endmodule
